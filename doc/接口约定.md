### restful api 中的返回值应包含以下部分:
#### e.g.: 
```
{
  code: 'SUCCESS', 
  msg: '', 
  data: { name: 'chikage', lv: 1, physical: 92, blood: 92, arcane: 0, fire: 0, bolt: 0, duraility: 120, kin: 100, beast: 100, }
}
```
#### 1.code: 
>每个请求必须携带一个code，用于给前端判断该请求的结果, 使之可以进行合理的处理  
#### 2.message | msg: 
>开发阶段，后端发放给前端的开发信息，再多的详细信息也是给开发人员看的，不可能直接作为结果给前端。而生产环境上，因尽可能减少提示防止恶意之徒获取相关内容。用于提高开发效率。（重点，开发阶段，开发阶段，开发阶段）  
#### 3.data: 
>返回的数据。这个就不用解释了  
  
  
#### code:（重点：不要用数字，不要用数字，不要用数字！用数字的朋友，可能是度过了一个漫长的2G网络时代。。）  
>`SUCCESS`:  
>* msg: 不需要  
>* 前端处理: 没啥好说的  
>* 后端处理:  
>
>`FAIL`: 前端无法处理的异常。失败的情况多种多样，前端根据情况反馈给用户，不要一股脑的把所有的失败都丢这里。（-WTF，Is anyone can tell me why？ -Who knows）    
>* msg: 放置后端异常以便后端处理, 或不处理  
>e.g:   
>* 前端处理: 反馈用户，操作失败.  
>* 后端处理：通过全局错误日志记录  
>这个信息后端应在开发阶段极可能处理，因为前段能给用户的反馈就是：看我玩死你，傻眼了吧  
>遇到过FAIL统一一个，然后把具体错误以句子形式写入msg的。导致前端的选择有三种：  
>1.反馈给用户，阁下操作失败，哈哈哈哈哈哈哈~。  
>2.判断code，再判断句子。  
>3.WTF！！  
>  
>`PARAMETER | PARAM`: 前端传递的参数无法通过后端的验证.
>* msg: 里面应该携带有哪个参数不正确，正确的区间是什么.
>e.g.:   
>player.name 的不能为 aaaaabbbbbccccddddd， 长度应为 1 - 10  
>* 前端处理: 根据后端msg，在请求前做个提醒.红叉叉，弹框什么的
>* 后端处理：
>后端判断个有没有传值，那么其实和不判断没什么区别，比如age：应判断0~150|200，按需，而不是判断有没有传年龄。不通过
>  
>`UNAUTHORIZED | UNAUTHORIZATION|UNAUTH`: 没有权限操作, 没有登录为主  
>* msg: 不需要  
>* 前端处理： 登录框  
>* 后端处理：返回前记入日志，info级别就好  
>初看之下，可能只是遇到些点击后需要登录的页面，或者登录超时请重新登录。 但实际情况有可能是有人恶意攻击。这时不应给予对方更多信息
>  
>`SERVICE|BUSINESS | BIZ`: 业务异常。有些异常是不需要处理的。提醒用户就好
>* msg: 不需要
>* 前端处理： 根据对应code，发出不一样的反馈，让用户明白，我不能这样操作, 比如：BLOG_OVER_COUNT-您今天已经发布三篇文章了，改天再发吧
>* 后端处理：
>任何一个前端不一样处理的，都可以归为此类，这部分是一个类别，而不是一个code  
  
  
#### data：除了SUCCESS，没有任何携带data的必要, 这样才能保证前端逻辑判断上有一个线性的流程
>* int: 只有请告诉我这个有多少的时候，才返回数字  
>e.g.: 请求用户总数  
>* bool: 请告诉我是不是正确的。更新数据  
>e.g.: 检查是否已经喜爱这边blog，
>有人可能认为更新失败不就丢FAIL吗？但可能有的情况要更新的值和原值一样，这时如果丢FAIL，那其实就很丢人了。用户想要的值和结果值一直，他只是不记得原来的值。这下好了，程序提醒了一下，你是SB，这叫用户作何感想。同样，前端也有可能针对一样的值给出一些提醒，很少很少  
>* str: 好像没遇到过  
>* obj: 请求详情都采用这个格式返回  
>* array: 请求列表  
    

遵循以上思路，你可以很好的复制你的业务代码。（没错，这里强调的就是复制，复制, 复制）
在下认为，千篇一律的代码不可怕，毕竟他们有各自负责的模块。可怕的是，命名复制了，还特地去改那一两个字母（那这样还真是闲人多活少了）

相比传统的restful会有些什么问题。采用http status来判断成功与否，我们看到大量的判断与try-catch在每一个请求中，难道你看着自己写的判断与try-catch，仅仅是为了应对后端的设计偷懒，你的心不会痛吗?

#### 既然已经有code 涵盖了所有的代码错误，http status用来干嘛呢：
>* 200: 尽可能的吧所有的问题都放到这里，方便前端统一处理
>* 401：使用200-code-unauth替代
>* 404: 保留，由于restful，看到这个基本说明前端代码没写对（请求地址）
>* 500: 保留, 后端处理，不应留到生产阶段  
  
#### 接下来到路径的定义了：  
> 一般一个完整的路径：主机地址/(权限划分)/请求内容
>* 1. 主机地址: 一般就是ip:port/(context)。主要看程序安防哪儿决定的  
>e.g.: http://127.0.0.1:8080/bloodborne  
>* 2. 权限划分: 如果是需要登录才能读取的数据，可以加上。把主要角色分类后，这个部分也就可以根据角色划分了。一般无权限要求时省略  
>e.g.: /admin/  
>* 3. 请求内容: 这里才是目标内容。按照restful规则，请求的资源/资源id  
>e.g.: /weapon/3368  
  
#### 请求类型： 
>请求类型是restful一个重要的部分。既然要用restful，那就请用请求类型来令同一个地址衍生不同操作  虽然还有其他多种多样的比如PATCH.但总体来说，以下四种是最为实用的。个人认为不是很有必要加入其他的进来添乱   
>* POST: 保存数据。以及一些无法定义的类型。比如登录，登出  
>e.g.: /admin/player(添加一个玩家)  
>* DELETE: 删除数据，  
>e.g.: /admin/player/843(删除玩家843)  
>* PUT: 修改数据，按照原本的定义，是用于更新全部，patch更新部分内容，但实际开发后，这两个部分挺容易混淆，还会给前端添乱，既然如此，更新全采用put就好，如果需要修改对应的字段，写明字段跟在id后面就好，即时使用patch，也是需要表明更新字段的  
>e.g.: /admin/player/821(修改玩家821)  
>* GET: 读取数据，无论是详情还是列表，或者是检查判断是否是某个条件，或者是否存在  
>  
#### 详情: 
>传递id即可  
>
#### 列表: 
>非特殊情况，比如数据量极大需要细分，条件复杂的时候。无论请求什么对象均采用统一采用相同的条件参数，而不是每个字段分别列出，可以极大的方便前后端开发。复杂情况可在此基础上再增加  
>* name/key/k: 关键条件，没有默认对应*。 后端获取到参数后，根据情况分配给不同的字段做为条件OR连接(鉴于现在普遍喜欢一个输入框，需求为希望id是这个值或者player.name是这个值的情况)  
>* minDate: 通用条件，不少数据希望通过时间筛选，至于时间该如何应用，则有后端选择。有没有要求这个时间一定是创建时间或者修改时间。与maxDate，可以形成一个区间。这种区间建议取值为人为理解的双开区间[]，而不是变成理解的开闭区间[)
>* maxDate: 
>* start/skip: 从第几个值开始取  
>* limit: 取几个值   
>* sortBy: 希望采用哪个字段排序。可以设置默认排序方式，如updateAt，但也应该把排序的选择权利留给前端  
>* sortByAZ: 正序还是倒序。默认配合更新时间，最好为倒序  
>  
>拓展: 这些基本条件一般是无法满足复杂条件的，这是需要进行拓展，最大值最小值采用一种名字，所有条件搜索下，范围的名字也都应该确定下来。  
>e.g.: 价格范围，minPrice-maxPrice  
>不得不说，从后端分页演变为前端分页，是可以减少后端负担，同时提高了前端的自由度。让代码更干净。这就是为什么不建议采用前端传页码的方式  
>对于请求登录者相关数据，推荐使用额外的接口，用me替代自己的id。  
>e.g.: /player/me(获取自己详情); /admin/player/849(admin来获取玩家849详情); /player/me/weapon/154/checkAvaliable(检查自己是否可以使用武器154)  
>通过例子可以看出，同样一个路径，几乎可以同时拥有四种类型，来形成四种不同的操作  
>请不要使用 POST: admin/player/update 的，说白了只是想返回json类型，然后就套上了restful的名号。有种挂羊头卖狗肉的感觉  
>但这么划分就会出现一个问题。第二部分是权限。但如果请求自己的信息(登录后才能看到), 难道要采用丑陋的user/user/338的路径格式吗  
