restful api 中的返回值应包含以下部分:
  e.g.: {code: 'SUCCESS', msg: '', data: {name: 'chikage', lv: 1, physical: 92, blood: 92, arcane: 0, fire: 0, bolt: 0, duraility: 120, kin: 100, beast: 100}}
  1.code: 每个请求必须携带一个code，用于给前端判断该请求的结果, 使之可以进行合理的处理
  2.message|msg: 开发阶段，后端发放给前端的开发信息，用于提高开发效率。（重点，开发阶段，开发阶段，开发阶段）
  3.data: 返回的数据。这个就不用解释了

  code: （重点：不要用数字，不要用数字，不要用数字。用数字的朋友，可能是度过了一个漫长的2G网络时代。。）
    SUCCESS: 
      msg: 不需要
      前端处理: 没啥好说的
      后端处理:

    FAIL: 前端无法处理的异常。失败的情况多种多样，前端根据情况反馈给用户，不要一股脑的吧所有的失败都丢这里。（-WTF，Is anyone can tell me why？ -Who knows）
      msg: 放置后端异常以便后端处理, 或不处理
        e.g: 
      前端处理: 反馈用户，操作失败.
      后端处理：通过全局错误日志记录
      这个信息后端应在开发阶段极可能处理，因为前段能给用户的反馈就是：看我玩死你，傻眼了吧
      遇到过FAIL统一一个，然后把具体错误以句子形式写入msg的。导致前端的选择有三种：1.反馈给用户，阁下操作失败，哈哈哈哈哈哈哈~。2.判断code，再判断句子。3.WTF！！

    PARAMETER|PARAM: 前端传递的参数无法通过后端的验证.
      msg: 里面应该携带有哪个参数不正确，正确的区间是什么.
        e.g.: player.name 的不能为 aaaaabbbbbccccddddd， 长度应为 1 - 10
      前端处理: 根据后端msg，在请求前做个提醒.红叉叉，弹框什么的
      后端处理：
      后端判断个有没有传值，那么其实和不判断没什么区别，比如age：应判断0~150|200，按需，而不是判断有没有传年龄。不通过，
    
    UNAUTHORIZED|UNAUTHORIZATION|UNAUTH: 没有权限操作, 没有登录为主
      msg: 不需要
      前端处理： 登录框
      后端处理：返回前记入日志，info级别就好
      初看只下，可能只是遇到些点击后需要登录的页面，或者登录超时请重新登录。 但实际情况有可能是有人恶意攻击。这时不应给予对方更多信息

    SERVICE|BUSINESS|BIZ: 业务异常。有些异常是不需要处理的。提醒用户就好
      msg: 不需要
      前端处理： 根据对应code，发出不一样的反馈，让用户明白，我不能这样操作, 比如：BLOG_OVER_COUNT-您今天已经发布三篇文章了，改天再发吧
      后端处理：
      任何一个前端不一样处理的，都可以归为此类，这部分是一个类别，而不是一个code

  data：除了SUCCESS，没有任何携带data的必要
    int: 只有请告诉我这个有多少的时候，才返回数字
      e.g.: 请求用户总数
    bool: 请告诉我是不是正确的。更新数据
      e.g.: 检查是否已经喜爱这边blog，
        有人可能认为更新失败不就丢FAIL吗？但可能有的情况要更新的值和原值一样，这时如果丢FAIL，那其实就很丢人了。用户想要的值和结果值一直，他只是不记得原来的值。这下好了，程序提醒了一下，你是SB，这叫用户作何感想。同样，前端也有可能针对一样的值给出一些提醒，很少很少
    str: 好像没遇到过
    obj: 请求详情都采用这个格式返回
    array: 请求列表
    

遵循以上思路，你可以很好的复制你的业务代码。（没错，这里强调的就是复制，复制, 复制）
在下认为，千篇一律的代码不可怕，毕竟他们有各自负责的模块。可怕的是，命名复制了，还特地去改那一两个字母（那这样还真是闲人多活少了）

相比传统的restful会有些什么问题。采用http status来判断成功与否，我们看到大量的判断与try-catch在每一个请求中，难道你看着自己写的判断与try-catch，仅仅是为了应对后端的设计偷懒，你的新不会痛吗?

既然已经有code 涵盖了所有的代码错误，http status用来干嘛呢：
  200: 尽可能的吧所有的问题都放到这里，方便前端统一处理
  401：使用200-code-unauth替代
  404: 保留，由于restful，看到这个基本说明前端代码没写对（请求地址）
  500: 保留, 后端处理，不应留到生产阶段

接下来到路径的定义了：
  一般一个完整的路径：主机地址/(权限划分)/请求内容
    1. 主机地址: 一般就是ip:port/(context)。主要看程序安防哪儿决定的
      e.g.: http://127.0.0.1:8080/bloodborne
    2. 权限划分: 如果是需要登录才能读取的数据，可以加上。把主要角色分类后，这个部分也就可以根据角色划分了。一般无权限要求时省略
      e.g.: /admin/
    3. 请求内容: 这里才是目标内容。按照restful规则，请求的资源/资源id
      e.g.: /weapon/3368
  
  请求类型： 请求类型是restful一个重要的部分。既然要用restful，那就请用请求类型来令同一个地址衍生不同操作
    虽然还有其他多种多样的比如PATCH.但总体来说，以下四种是最为实用的。个人认为不是很有必要加入其他的进来添乱
    POST: 保存数据。以及一些无法定义的类型。比如登录，登出
      e.g.: /admin/player(添加一个玩家)
    DELETE: 删除数据，
      e.g.: /admin/player/843(删除玩家843)
    PUT: 修改数据，按照原本的定义，是用于更新全部，patch更新部分内容，但实际开发后，这两个部分挺容易混淆，还会给前端添乱，既然如此，更新全采用put就好，如果需要修改对应的字段，写明字段跟在id后面就好，即时使用patch，也是需要表明更新字段的
      e.g.: /admin/player/821(修改玩家821)
    GET: 读取数据，无论是详情还是列表，或者是检查判断是否是某个条件，或者是否存在
      详情: 传递id即可
      列表: 非特殊情况，比如数据量极大需要细分，条件复杂的时候。无论请求什么对象均采用统一采用相同的条件参数，而不是每个字段分别列出，可以极大的方便前后端开发。复杂情况可在此基础上再增加
        name/key/k: 关键条件，没有默认对应*。 后端获取到参数后，根据情况分配给不同的字段做为条件OR连接(鉴于现在普遍喜欢一个输入框，需求为希望id是这个值或者player.name是这个值的情况)
        minDate: 通用条件，不少数据希望通过时间筛选，至于时间该如何应用，则有后端选择。有没有要求这个时间一定是创建时间或者修改时间。与maxDate，可以形成一个区间。这种区间建议取值为人为理解的双开区间[]，而不是变成理解的开闭区间[)
        maxDate: 
        start/skip: 从第几个值开始取
        limit: 取几个值
        sortBy: 希望采用哪个字段排序。可以设置默认排序方式，如updateAt，但也应该把排序的选择权利留给前端
        sortByAZ: 正序还是倒序。默认配合更新时间，最好为倒序

        不得不说，从后端分页演变为前端分页，是可以减少后端负担，同时提高了前端的自由度。让代码更干净。这就是为什么不建议采用前端传页码的方式


      对于请求登录者相关数据，推荐使用额外的接口，用me替代自己的id。
      e.g.: /player/me(获取自己详情); /admin/player/849(admin来获取玩家849详情); /player/me/weapon/154/checkAvaliable(检查自己是否可以使用武器154)

    通过例子可以看出，同样一个路径，几乎可以同时拥有四种类型，来形成四种不同的操作
    请不要使用 POST: admin/player/update 的，说白了只是想返回json类型，然后就套上了restful的名号。有种挂羊头卖狗肉的感觉
    
    但这么划分就会出现一个问题。第二部分是权限。但如果请求自己的信息(登录后才能看到), 难道要采用丑陋的user/user/338的路径格式吗
